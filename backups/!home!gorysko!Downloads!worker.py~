#!/usr/bin/python

import os
import subprocess
import sys

import multiprocessing

import threading
import Queue

from multiprocessing import Pool, cpu_count, log_to_stderr


def execute(commands, inputs=None):
    "Execute commands in a system-independent manner"
    if inputs is not None:
        stdin_redir = subprocess.PIPE
    else:
        stdin_redir = None
    proc = subprocess.Popen(commands, stdin=stdin_redir,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE)
    try:
        out, err = proc.communicate(input=inputs)
        retcode = proc.returncode
        return out, err, retcode
    except OSError, ex:
        sys.stderr.write("%r %r returned %r" % (commands, inputs[:40], ex))
        raise

def get_path():
    """Gets path for saving data."""
    path = os.getcwd()
    analysis_path = os.path.join(os.path.dirname(os.path.abspath(__file__)),
                            '285_analysis')
    if not (os.path.exists(analysis_path) and os.path.isdir(analysis_path)):
        sys.stderr.write("Cannot find the 285_analysis directory! Aborting!")
        sys.exit(3)
    return path, analysis_path


# 3. Populate the tasks queue. Main loop.
def main_loop(curr_path, analysis, queue):
    """Main loop of function."""
    counter = 0 # serial number of the current task
    for infile in sys.argv[1:]:
        if not os.path.exists(infile):
            sys.stderr.write("%s does not exist, skipping" % infile)
            continue
        sys.stderr.write("Processing %s." % infile)
        with open(infile) as source:
            os.chdir(analysis)
            for line in source:
                line = line.strip()
                fragments = line.split(' ')
                args = fragments[2:]
                for arg in args:
                    if not os.path.exists(arg + '.psq'):
                        formatdb = ['formatdb', '-i', arg]
                        out, err, retcode = execute(formatdb)
                        sys.stderr.write('formatted %s: %s' % (arg,
                        				' '.join(formatdb)))
                        if retcode != 0:
                            sys.stderr.write(
                            			('formatdb returned' + retcode + ':'),
                            			(err +' while formatting' + arg),
                            			(' full output follows:\n' + out))
                counter += 1
                queue.put((counter, args))
            os.chdir(curr_path)

def worker(analysis_path, tasks):
    'parallel worker for single command'
    os.chdir(analysis_path)
    try:
        (counter, args) = tasks.get()
    except ValueError:
        sys.stderr.write(
        	"worker(tasks) encountered an exception trying tasks.get()")
        raise
    if args[0] == 'STOP':
        sys.stderr.write("STOP found, exiting.")
        return
    blast = ['inparanoid.pl', '--blast-only']
    blast.extend(args)
    sys.stderr.write('Start blast %s: %s' % (counter, ' '.join(blast)))
    out, err, retcode = execute(blast)
    sys.stderr.write(' Done blast %s: %s' % (counter, ' '.join(blast)))
    if retcode != 0:
        sys.stderr.write(('inparanoid returned' + retcode + ':'),
        				 (err + ' while blasting' + ' and '.join(args))
        				 (', full output follows:\n' + out))


def run_worker(path, analysis_path):
    """Runs worker."""
    num_workers = cpu_count()
    qsize = 10 * num_workers
    queue = multiprocessing.Queue(maxsize=qsize)
    workers = []
    helper = len(range(num_workers))
    while helper:
        process = multiprocessing.Process(target=worker, args=(analysis_path,
        													   queue,))
        workers.append(process)
        process.start()
        helper -= 1
    main_loop(path, analysis_path, queue)
    sys.stderr.write("Adding %s STOP messages to task_queue." % num_workers)
    helper = len(range(num_workers))
    while helper:
        queue.put((0, ['STOP']))
        helper -= 1
    for process in workers:
        process.join()
    queue.close()

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print "At least one file with inparanoid commands must be provided!"
        print "Example: %s commands_0.txt [commands_1.txt [...]]" % sys.argv[0]
        sys.exit(2)
    CUSTOM_INPARANOID = os.path.join(os.path.dirname(os.path.abspath(__file__)),
    					'custom_inparanoid')
    os.environ['PATH'] = CUSTOM_INPARANOID + ':' + os.environ['PATH']
    del CUSTOM_INPARANOID
    CURR_PATH, ANALYSIS = get_path()
    run_worker(CURR_PATH, ANALYSIS)
